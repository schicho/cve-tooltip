const CVE_REGEX = /CVE-[0-9]{4}-[0-9]+/gm;

const CVE_TOOLTIP_MARKER = function () {
    let marker = document.createElement("span");
    marker.style.fontFamily = "arial, helvetica, ariel, sans-serif";
    marker.style.fontWeight = "bold";
    marker.style.fontSize = "0.5em";

    marker.style.backgroundColor = "orange";
    marker.style.color = "black";

    marker.style.padding = "0.1em";
    marker.style.display = "inline-block";

    // Make sure we use a sane text layout
    marker.style.textTransform = "none";
    marker.style.textAlign = "left";
    marker.style.whiteSpace = "normal";
    marker.style.letterSpacing = "normal";
    marker.style.wordSpacing = "normal";
    return marker;
}();

const CVE_TOOLTIP_POPUP = function () {
    let popup = document.createElement("div");
    popup.style.display = "none";
    popup.style.position = "absolute";
    popup.style.width = "15rem";
    popup.style.maxWidth = "100vw";

    popup.style.backgroundColor = "black";
    popup.style.color = "white";

    popup.style.fontSize = "0.8rem";
    popup.style.fontWeight = "normal";

    popup.style.padding = "0.2em";
    popup.style.borderRadius = "0.2em";

    popup.style.zIndex = "1";
    return popup;
}();

const CVE_TOOLTIP_P = function () {
    let p = document.createElement("p");
    p.style.margin = "5px";
    return p;
}();

// On page load we process the whole DOM looking for CVEs.
// Additionally, we set up a MutationObserver to process new nodes, which may be dynamically added.
document.addEventListener('DOMContentLoaded', function () {
    processDOM(document.body);
    initMO(document.body);
});

// Starting from the root node, we recursively traverse the DOM tree and look for text nodes containing CVEs.
// For each CVE found, we create a tooltip element that will be added to the DOM.
async function processDOM(root) {
    let CVETextNodes = findCVETextNodesRecursive(root);
    CVETextNodes.forEach((node) => {
        createCVETooltip(node);
    });
}

// Create a tooltip element for a given text node containing a CVE.
// As a text node may contain multiple CVEs, we create a tooltip element for each one.
async function createCVETooltip(node) {
    let cveText = node.nodeValue;
    let cves = cveText.match(CVE_REGEX);

    // May be the case as we also call this function from the MutationObserver,
    // not just on pre-filtered text nodes.
    if (cves === null) {
        return;
    }

    cves.forEach(async (cve) => {
        let markerSpan = CVE_TOOLTIP_MARKER.cloneNode();
        markerSpan.textContent = "CVE";

        // create child which pops up when hovering over the cve
        let popupDiv = CVE_TOOLTIP_POPUP.cloneNode();

        let headerParagraph = CVE_TOOLTIP_P.cloneNode();
        headerParagraph.style.fontWeight = "bold";
        let descParagraph = CVE_TOOLTIP_P.cloneNode();

        const response = await chrome.runtime.sendMessage({ "CVEIdentifier": cve });
        headerParagraph.textContent = response.title + " â€“ " + response.score;
        descParagraph.textContent = response.description;

        let moreInfoParagraph = CVE_TOOLTIP_P.cloneNode();
        moreInfoParagraph.style.color = "orange";
        moreInfoParagraph.style.cursor = "pointer";
        moreInfoParagraph.textContent = "> More info on NVD";

        popupDiv.appendChild(headerParagraph);
        popupDiv.appendChild(descParagraph);
        popupDiv.appendChild(moreInfoParagraph);
        markerSpan.appendChild(popupDiv);

        moreInfoParagraph.addEventListener("click", function () {
            window.open("https://nvd.nist.gov/vuln/detail/" + cve, "_blank");
        });

        // desktop: open on hover, close on mouseout
        markerSpan.addEventListener("mouseover", function () {
            popupDiv.style.display = "block";
        });
        markerSpan.addEventListener("mouseout", function () {
            popupDiv.style.display = "none";
        });

        // mobile: open on click, close on click outside
        markerSpan.addEventListener("click", function () {
            popupDiv.style.display = "block";
        });
        document.addEventListener("click", function (event) {
            if (!markerSpan.contains(event.target)) {
                popupDiv.style.display = "none";
            }
        });

        node.parentNode.insertBefore(markerSpan, node.nextSibling);
    });
}

// Recursively traverse the DOM tree looking for text nodes containing CVEs.
// Returns an array of text nodes containing CVEs.
// Editable nodes are skipped.
function findCVETextNodesRecursive(node) {
    if (checkForEditableNode(node)) {
        return [];
    }

    let CVETextNodes = [];
    switch (node.nodeType) {
        case 1: // Element
        case 9: // Document
        case 11: // Document fragment

            for (let i = 0; i < node.childNodes.length; i++) {
                let child = node.childNodes[i];
                if (/SCRIPT|STYLE|IMG|NOSCRIPT|TEXTAREA|CODE/i.test(child.nodeName) === false) {
                    CVETextNodes = CVETextNodes.concat(findCVETextNodesRecursive(child));
                }
            }
            break;
        case 3: // Text node
            if (checkForCVE(node)) {
                return [node];
            }
        default:
            break;
    }
    return CVETextNodes;
}

function checkForCVE(node) {
    let text = node.nodeValue;
    if (text === null || text === undefined) {
        return false;
    }
    return text.match(CVE_REGEX) !== null;
}

function checkForEditableNode(el) {
    try {
        var namedNodeMap = el.attributes;

        for (var i = 0; i < namedNodeMap.length; i++) {
            var attr = namedNodeMap.item(i);
            if (attr.name === "contenteditable") {

                return true;
            } else if (attr.name === "class" && attr.value === "notranslate") {

                return true;
            } else if (attr.name === "translate" && attr.value === "no") {

                return true;
            } else if (attr.name === "role" && attr.value === "textbox") {

                return true;
            }
        }
    } catch (error) { }
    return false;
}

function initMO(root) {
    MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
    const observer = new MutationObserver(function (mutations, observer) {
        for (const mutation of mutations) {
            for (const addedNode of mutation.addedNodes) {
                if (addedNode.nodeType == 3) { // text node
                    if (checkForEditableNode(addedNode)) {
                        continue;
                    }
                    if (checkForCVE(addedNode)) {
                        createCVETooltip(addedNode);
                    }
                } else {
                    processDOM(addedNode);
                }
            }
        }
    });
    observer.takeRecords();
    observer.observe(root, {
        characterData: false,
        childList: true,
        subtree: true
    });
}
