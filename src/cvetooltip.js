const CVE_REGEX = /CVE-[0-9]{4}-[0-9]+/gm;

const TOOLTIP_STYLES = `
    .cve-tooltip-marker {
        all: initial;
        font-family: arial, helvetica, ariel, sans-serif;
        font-weight: bold;
        font-size: 0.5em;
        background-color: orange;
        color: black;
        padding: 0.1em;
        display: inline-block;

        text-transform: none;
        text-align: left;
        white-space: normal;
        letter-spacing: normal;
        word-spacing: normal;
    }

    .cve-tooltip-popup {
        display: none;
        position: absolute;
        width: 6cm;
        max-width: 100vw;
        background-color: black;
        color: white;
        font-size: 12px;
        font-weight: normal;
        padding: 5px;
        border-radius: 5px;
        z-index: 1;
    }

    .cve-tooltip-popup p {
        padding: 0;
        margin: 5px;
    }
`;

const CVE_TOOLTIP_MARKER = function () {
    let marker = document.createElement("span");
    marker.classList.add("cve-tooltip-marker");
    return marker;
}();

const CVE_TOOLTIP_POPUP = function () {
    let popup = document.createElement("div");
    popup.classList.add("cve-tooltip-popup");
    return popup;
}();

const CVE_TOOLTIP_P = function () {
    let p = document.createElement("p");
    return p;
}();

// On page load we process the whole DOM looking for CVEs.
// Additionally, we set up a MutationObserver to process new nodes, which may be dynamically added.
document.addEventListener('DOMContentLoaded', function () {
    const TOOLTIP_STYLESHEET = document.createElement("style");
    TOOLTIP_STYLESHEET.textContent = TOOLTIP_STYLES;
    TOOLTIP_STYLESHEET.id = "cve-tooltip-stylesheet";
    document.head.appendChild(TOOLTIP_STYLESHEET);

    processDOM(document.body);
    initMO(document.body);
});

// Starting from the root node, we recursively traverse the DOM tree and look for text nodes containing CVEs.
// For each CVE found, we create a tooltip element that will be added to the DOM.
async function processDOM(root) {
    let CVETextNodes = findCVETextNodesRecursive(root);
    CVETextNodes.forEach((node) => {
        createCVETooltip(node);
    });
}

// Create a tooltip element for a given text node containing a CVE.
// As a text node may contain multiple CVEs, we create a tooltip element for each one.
async function createCVETooltip(node) {
    let cveText = node.nodeValue;
    let cves = cveText.match(CVE_REGEX);

    // May be the case as we also call this function from the MutationObserver,
    // not just on pre-filtered text nodes.
    if (cves === null) {
        return;
    }

    cves.forEach(async (cve) => {
        let markerSpan = CVE_TOOLTIP_MARKER.cloneNode();
        markerSpan.textContent = "CVE";

        // create child which pops up when hovering over the cve
        let popupDiv = CVE_TOOLTIP_POPUP.cloneNode();

        let headerParagraph = CVE_TOOLTIP_P.cloneNode();
        headerParagraph.style.fontWeight = "bold";
        let descParagraph = CVE_TOOLTIP_P.cloneNode();

        const response = await chrome.runtime.sendMessage({ "CVEIdentifier": cve });
        headerParagraph.textContent = response.title + " â€“ " + response.score;
        descParagraph.textContent = response.description;

        let moreInfoParagraph = CVE_TOOLTIP_P.cloneNode();
        moreInfoParagraph.style.color = "orange";
        moreInfoParagraph.style.cursor = "pointer";
        moreInfoParagraph.textContent = "> More info on NVD";

        popupDiv.appendChild(headerParagraph);
        popupDiv.appendChild(descParagraph);
        popupDiv.appendChild(moreInfoParagraph);
        markerSpan.appendChild(popupDiv);

        moreInfoParagraph.addEventListener("click", function () {
            window.open("https://nvd.nist.gov/vuln/detail/" + cve, "_blank");
        });

        // desktop: open on hover, close on mouseout
        markerSpan.addEventListener("mouseover", function () {
            popupDiv.style.display = "block";
        });
        markerSpan.addEventListener("mouseout", function () {
            popupDiv.style.display = "none";
        });

        // mobile: open on click, close on click outside
        markerSpan.addEventListener("click", function () {
            popupDiv.style.display = "block";
        });
        document.addEventListener("click", function (event) {
            if (!markerSpan.contains(event.target)) {
                popupDiv.style.display = "none";
            }
        });

        node.parentNode.insertBefore(markerSpan, node.nextSibling);
    });
}

// Recursively traverse the DOM tree looking for text nodes containing CVEs.
// Returns an array of text nodes containing CVEs.
// Editable nodes are skipped.
function findCVETextNodesRecursive(node) {
    if (checkForEditableNode(node)) {
        return [];
    }

    let CVETextNodes = [];
    switch (node.nodeType) {
        case 1: // Element
        case 9: // Document
        case 11: // Document fragment

            for (let i = 0; i < node.childNodes.length; i++) {
                let child = node.childNodes[i];
                if (/SCRIPT|STYLE|IMG|NOSCRIPT|TEXTAREA|CODE/i.test(child.nodeName) === false) {
                    CVETextNodes = CVETextNodes.concat(findCVETextNodesRecursive(child));
                }
            }
            break;
        case 3: // Text node
            if (checkForCVE(node)) {
                return [node];
            }
        default:
            break;
    }
    return CVETextNodes;
}

function checkForCVE(node) {
    let text = node.nodeValue;
    if (text === null || text === undefined) {
        return false;
    }
    return text.match(CVE_REGEX) !== null;
}

function checkForEditableNode(el) {
    try {
        var namedNodeMap = el.attributes;

        for (var i = 0; i < namedNodeMap.length; i++) {
            var attr = namedNodeMap.item(i);
            if (attr.name === "contenteditable") {

                return true;
            } else if (attr.name === "class" && attr.value === "notranslate") {

                return true;
            } else if (attr.name === "translate" && attr.value === "no") {

                return true;
            } else if (attr.name === "role" && attr.value === "textbox") {

                return true;
            }
        }
    } catch (error) { }
    return false;
}

function initMO(root) {
    MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
    const observer = new MutationObserver(function (mutations, observer) {
        for (const mutation of mutations) {
            for (const addedNode of mutation.addedNodes) {
                if (addedNode.nodeType == 3) { // text node
                    if (checkForEditableNode(addedNode)) {
                        continue;
                    }
                    if (checkForCVE(addedNode)) {
                        createCVETooltip(addedNode);
                    }
                } else {
                    processDOM(addedNode);
                }
            }
        }
    });
    observer.takeRecords();
    observer.observe(root, {
        characterData: false,
        childList: true,
        subtree: true
    });
}
